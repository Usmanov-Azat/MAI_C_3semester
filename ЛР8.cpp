#define _CRT_SECURE_NO_DEPRECATE

#include <stdio.h>
#include <stdbool.h>
#include <locale.h>
#include <cstdlib>

//*******************ASCii КОДЫ*************************

//45			ТИРЕ   "-"
//32		    ПРОБЕЛ " "

//65			ЗАГЛАВНАЯ БУКВА "A" АНГЛИЙСКОГО АЛФАВИТА
//90		    ЗАГЛАВНАЯ БУКВА "Z" АНГЛИЙСКОГО АЛФАВИТА
//97		    ПРОПИСНАЯ БУКВА "a" АНГЛИЙСКОГО АЛФАВИТА
//122			ПРОПИСНАЯ БУКВА "z" АНГЛИЙСКОГО АЛФАВИТА

//192			ЗАГЛАВНАЯ БУКВА "А" РУССКОГО АЛФАВИТА
//223		    ЗАГЛАВНАЯ БУКВА "Я" РУССКОГО АЛФАВИТА
//224		    ПРОПИСНАЯ БУКВА "а" РУССКОГО АЛФАВИТА
//255			ПРОПИСНАЯ БУКВА "я" РУССКОГО АЛФАВИТА

//*******************************************************


bool isLetter(unsigned char symb);		// ФУНКЦИЯ ПРОВЕРКИ СИМВОЛОВ

int findLongestWord(FILE* input);		// ФУНКЦИЯ НАХОЖДЕНИЯ МАКСИМАЛЬНОЙ ДЛИНЫ СЛОВА В ФАЙЛЕ

void fillMas(int* mas, FILE* input);	// ФУНКЦИЯ ЗАПОЛНЕНИЯ МАССИВА С КОЛИЧЕСТВОМ СЛОВ РАЗЛИЧНОЙ ДЛИНЫ

void main()
{
	setlocale(LC_ALL, "RUSSIAN");    // ПОДКЛЮЧЕНИЕ РУССКОГО ЯЗЫКА

	FILE* input;		// УКАЗАТЕЛЬ НА ФАЙЛ ВВОДА
	FILE* output;		// УКАЗАТЕЛЬ НА ФАЙЛ ВЫВОДА

	int i = 0;			// ИНДЕКСНАЯ ПЕРЕМЕННАЯ
	int maxLen = 0;		// МАКСИМАЛЬНАЯ ДЛИНА СЛОВА В ФАЙЛЕ

	int* wordLenMas;	// УКАЗАТЕЛЬ НА МАССИВ ДЛИН СЛОВ В ФАЙЛЕ

	// ОТКРЫТИЕ ФАЙЛА ДЛЯ ЧТЕНИЯ
	input = fopen("input.txt", "r");
	// ОТКРЫТИЕ ФАЙЛА ДЛЯ ЗАПИСИ
	output = fopen("output.txt", "w");

	if (input != NULL)
	{
		// НАХОЖДЕНИЕ МАКСИМАЛЬНОЙ ДЛИНЫ СЛОВА 
		maxLen = findLongestWord(input);

		// ВОЗВРАТ В НАЧАЛО ФАЙЛА
		rewind(input);

		// ВЫДЕЛЕНИЕ ПАМЯТИ ПОД МАССИВ ДЛИН СЛОВ
		wordLenMas = (int*)malloc((maxLen + 1) * sizeof(int));

		// ИНИЦИАЛИЗАЦИЯ МАССИВА ДЛИН СЛОВ
		for (i = 0; i <= maxLen; i++)
		{
			wordLenMas[i] = 0;
		}//for

		// ЗАПОЛНЕНИЕ МАССИВА ДЛИНАМИ СЛОВ
		fillMas(wordLenMas, input);

		// ЗАПИСЬ В НУЛЕВОЙ ЭЛЕМЕНТ МАССИВА ОБЩЕГО ЧИСЛА СЛОВ ИЗ ФАЙЛА
		for (i = 1; i <= maxLen; i++)
		{
			wordLenMas[0] = wordLenMas[0] + wordLenMas[i];
		}//for

		// ВЫВОД ПОЛУЧЕННОГО МАССИВА В ФАЙЛ И НА ЭКРАН
		//printf("Максимальная длина слова в файле: %d\n\n", maxLen);
		//fprintf(output, "Максимальная длина слова в файле: %d\n\n", maxLen);

		printf("Всего слов: %d\n\n", wordLenMas[0]);
		fprintf(output, "Всего слов: %d\n\n", wordLenMas[0]);

		for (i = 1; i <= maxLen; i++)
		{
			printf("	Всего слов длины %d: %d\n", i, wordLenMas[i]);
			fprintf(output, "	Всего слов длины %d: %d\n", i, wordLenMas[i]);
		}//for

		// ОСВОБОЖДЕНИЕ ПАМЯТИ, ВЫДЕЛЕННОЙ ПОД МАССИВ
		free(wordLenMas);

		// ЗАКРЫТИЕ ФАЙЛА ВВОДА
		fclose(input);
	}//if
	else
	{
		printf("Ошибка при открытии файла для чтения");
		fprintf(output, "Ошибка при открытии файла для чтения");
	}//else

	// ЗАКРЫТИЕ ФАЙЛА ВЫВОДА
	fclose(output);
}//main

bool isLetter(unsigned char symb)						// ФУНКЦИЯ ПРОВЕРКИ СИМВОЛОВ
{
	if ((symb >= 65) && (symb <= 90)) 					// ЕСЛИ СИМВОЛ ЛЕЖИТ В ОТРЕЗКЕ "A" - "Z" 
	{
		return true;									// ВЕРНУТЬ ЗНАЧЕНИЕ "ИСТИНА"
	}//if
	if ((symb >= 97) && (symb <= 122)) 					// ЕСЛИ СИМВОЛ ЛЕЖИТ В ОТРЕЗКЕ "a" - "z"  
	{
		return true;									// ВЕРНУТЬ ЗНАЧЕНИЕ "ИСТИНА"
	}//if
	if ((symb >= 192) && (symb <= 223)) 				// ЕСЛИ СИМВОЛ ЛЕЖИТ В ОТРЕЗКЕ "А" - "Я" 
	{
		return true;									// ВЕРНУТЬ ЗНАЧЕНИЕ "ИСТИНА"
	}//if
	if ((symb >= 224) && (symb <= 255)) 				// ЕСЛИ СИМВОЛ ЛЕЖИТ В ОТРЕЗКЕ "а" - "я"  
	{
		return true;									// ВЕРНУТЬ ЗНАЧЕНИЕ "ИСТИНА"
	}//if
	if (symb == 45) 									// ЕСЛИ СИМВОЛ "-"  
	{
		return true;									// ВЕРНУТЬ ЗНАЧЕНИЕ "ИСТИНА"
	}//if
	return false;										// ИНАЧЕ ВЕРНУТЬ ЗНАЧЕНИЕ "ЛОЖЬ"
}//is_letter

int findLongestWord(FILE* input)					  // ФУНКЦИЯ НАХОЖДЕНИЯ МАКСИМАЛЬНОЙ ДЛИНЫ СЛОВА В ФАЙЛЕ
{
	int maxLen = 0;									  // МАКСИМАЛЬНАЯ ДЛИНА СЛОВА
	int wordLen = 0;								  // ДЛИНА ТЕКУЩЕГО СЛОВА
	int i = 0;										  // ИНДЕКСНАЯ ПЕРЕМЕННАЯ

	bool isWord = false;							  // ФЛАГ
	char str[256];									  // БУФЕР

	while (fgets(str, 256, input) != NULL)			  // ПОКА НЕ КОНЕЦ ФАЙЛА
	{
		i = 0;										  // ОБНУЛЕНИЕ ИНДЕКСНОЙ ПЕРЕМЕННОЙ
		while (str[i] != '\0')						  // ПОКА СЛЕДУЮЩИЙ СИМВОЛ - НЕ КОНЕЦ СТРОКИ
		{
			if (isWord == false)					  // ЕСЛИ СЛОВО НЕ НАЧАЛОСЬ
			{
				if (isLetter(str[i]) == true) 		  // ЕСЛИ ТЕКУЩИЙ СИМВОЛ - БУКВА
				{
					isWord = true;					  // СЛОВО НАЧАЛОСЬ. МЕНЯЕМ ЗНАЧЕНИЕ ФЛАГА НА "ИСТИНА"
					wordLen = 0;					  // ОБНУЛЯЕМ ДЛИНУ ТЕКУЩЕГО СЛОВА
				}//if
			}//if
			if (isWord == true)						  // ЕСЛИ СЛОВО НАЧАЛОСЬ
			{
				wordLen = wordLen + 1;				  // УВЕЛИЧИВАЕМ ДЛИНУ ТЕКУЩЕГО СЛОВА НА 1
				if (isLetter(str[i + 1]) == false)	  // ЕСЛИ СЛЕДУЮЩИЙ СИМВОЛ - НЕ БУКВА
				{
					if (wordLen > maxLen)			  // ЕСЛИ ДЛИНА ТЕКУЩЕГО СЛОВА БОЛЬШЕ МАКСИМАЛЬНОЙ ДЛИНЫ СЛОВА
					{
						maxLen = wordLen;			  // ПРИСВАИВАЕМ МАКСИМАЛЬНОЙ ДЛИНЕ СЛОВА ЗНАЧЕНИЕ ТЕКУЩЕЙ ДЛИНЫ СЛОВА
					}//if
					isWord = false;					  // СЛОВО ЗАКОНЧИЛОСЬ. МЕНЯЕМ ЗНАЧЕНИЕ ФЛАГА НА "ЛОЖЬ"
					wordLen = 0;					  // ОБНУЛЯЕМ ДЛИНУ СЛОВА
				}//if
			}//if
			i = i + 1;								  // УВЕЛИЧИВАЕМ ЗНАЧЕНИЕ ИНДЕКСНОЙ ПЕРЕМЕННОЙ НА ОДИН
		}//while
	}//while
	return maxLen;									  // ВЕРНУТЬ НАЙДЕННОЕ ЗНАЧЕНИЕ МАКСИМАЛЬНОЙ ДЛИНЫ СЛОВА
}//findLongestWord

void fillMas(int* mas, FILE* input)						// ФУНКЦИЯ ЗАПОЛНЕНИЯ МАССИВА С КОЛИЧЕСТВОМ СЛОВ РАЗЛИЧНОЙ ДЛИНЫ
{
	int wordLen = 0;									// ДЛИНА ТЕКУЩЕГО СЛОВА
	int i = 0;											// ИНДЕКСНАЯ ПЕРЕМЕННАЯ

	bool isWord = false;								// ФЛАГ
	char str[256];										// БУФЕР

	while (fgets(str, 256, input) != NULL)				// ПОКА НЕ КОНЕЦ ФАЙЛА
	{
		i = 0;											// ОБНУЛЕНИЕ ИНДЕКСНОЙ ПЕРЕМЕННОЙ
		while (str[i] != '\0')							// ПОКА	СЛЕДУЮЩИЙ СИМВОЛ - НЕ КОНЕЦ СТРОКИ
		{
			if (isWord == false)						// ЕСЛИ СЛОВО НЕ НАЧАЛОСЬ
			{
				if (isLetter(str[i]) == true) 			// ЕСЛИ ТЕКУЩИЙ СИМВОЛ - БУКВА
				{
					isWord = true;						// СЛОВО НАЧАЛОСЬ. МЕНЯЕМ ЗНАЧЕНИЕ ФЛАГА НА "ИСТИНА"
					wordLen = 0;						// ОБНУЛЯЕМ ДЛИНУ СЛОВА
				}//if
			}//if
			if (isWord == true)							// ЕСЛИ СЛОВО НАЧАЛОСЬ
			{
				wordLen = wordLen + 1;					// УВЕЛИЧИВАЕМ ДЛИНУ ТЕКУЩЕГО СЛОВА НА 1 
				if (isLetter(str[i + 1]) == false)		// ЕСЛИ СЛЕДУЮЩИЙ СИМВОЛ - НЕ БУКВА
				{
					mas[wordLen] = mas[wordLen] + 1;	// УВЕЛИЧЕНИЕ КОЛИЧЕСТВА СЛОВ В МАССИВЕ С ДЛИНОЙ wordLen НА 1
					isWord = false;						// СЛОВО ЗАКОНЧИЛОСЬ. МЕНЯЕМ ЗНАЧЕНИЕ ФЛАГА НА "ЛОЖЬ"
					wordLen = 0;						// ОБНУЛЯЕМ ДЛИНУ СЛОВА
				}//if
			}//if
			i = i + 1;									// УВЕЛИЧИВАЕМ ЗНАЧЕНИЕ ИНДЕКСНОЙ ПЕРЕМЕННОЙ НА ОДИН
		}//while
	}//while
}//fillMas